using System;
using System.IO;
using System.Linq;
using System.Text;

namespace UnityEditor.ShaderGraph
{
    public static class ValueStructGenerator
    {
        private static string ValueTypeName(int componentCount)
            => componentCount == 1 ? "Float" : $"Float{componentCount}";

        private static string AnyVectorTypeName(int minComponentCount)
            => minComponentCount == 1 ? "AnyFloat" : $"AnyFloat{minComponentCount}";

        private static char SwizzleComponentName(int v)
            => v == 3 ? 'w' : (char)('x' + v);

        private static string SwizzleName(char[] swizzleNames, int componentCount)
            => String.Concat(Enumerable.Take(swizzleNames, componentCount).Reverse());

        private static void GenerateSwizzle(StringBuilder sb, int maxComponents)
        {
            var swizzleName = new char[4];
            for (int swizzleComponents = 1; swizzleComponents <= 4; ++swizzleComponents)
            {
                var typeName = ValueTypeName(swizzleComponents);
                for (int i = 0; i < (int)Math.Pow(maxComponents, swizzleComponents); ++i)
                {
                    swizzleName[0] = SwizzleComponentName(i % maxComponents);
                    swizzleName[1] = SwizzleComponentName((i / maxComponents) % maxComponents);
                    swizzleName[2] = SwizzleComponentName((i / maxComponents / maxComponents) % maxComponents);
                    swizzleName[3] = SwizzleComponentName((i / maxComponents / maxComponents / maxComponents) % maxComponents);
                    var swizzle = SwizzleName(swizzleName, swizzleComponents);
                    sb.Append($"\t\tpublic {typeName} {swizzle}\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{Code}}).{swizzle}\" }};\n");
                    sb.Append("\n");
                }
            }
        }

        [MenuItem("Tools/SG/GenerateCs")]
        public static void Generate()
        {
            string path = "Packages/com.unity.shadergraph/Editor/Data/Nodes/CodeGen/Values.gen.cs";

            using (var stream = new StreamWriter(path))
            {
                var sb = new StringBuilder();
                sb.Append("// Auto-generated by Tools/SG/GenerateCs menu. DO NOT hand edit.\n");
                sb.Append("namespace UnityEditor.ShaderGraph.Hlsl\n");
                sb.Append("{\n");

                for (int i = 1; i <= 4; ++i)
                {
                    var typeName = ValueTypeName(i);
                    sb.Append($"\tpublic struct {typeName}\n");
                    sb.Append("\t{\n");
                    sb.Append($"\t\tpublic string Code;\n\n");

                    sb.Append("\t\t// C# doesn't allow overloading operator=...\n");
                    sb.Append($"\t\tpublic void AssignFrom({typeName} other)\n");
                    sb.Append("\t\t{\n");
                    sb.Append("\t\t\tCode = other.Code;\n");
                    sb.Append("\t\t}\n\n");

                    if (i == 1)
                    {
                        for (int j = 2; j <= 4; ++j)
                        {
                            var otherTypeName = ValueTypeName(j);
                            sb.Append($"\t\tpublic static implicit operator {otherTypeName}(Float x)\n");
                            sb.Append($"\t\t\t=> new {otherTypeName}() {{ Code = $\"({{x.Code}}.{String.Concat(Enumerable.Repeat("x", j))}\" }};\n");
                            sb.Append("\n");
                        }
                    }

                    if (i == 4)
                    {
                        sb.Append("\t\tpublic string Trim(int components)\n");
                        sb.Append("\t\t{\n");
                        sb.Append("\t\t\tif (components == 1)\n");
                        sb.Append("\t\t\t\treturn \".x\";\n");
                        sb.Append("\t\t\telse if (components == 2)\n");
                        sb.Append("\t\t\t\treturn \".xy\";\n");
                        sb.Append("\t\t\telse if (components == 3)\n");
                        sb.Append("\t\t\t\treturn \".xyz\";\n");
                        sb.Append("\t\t\telse\n");
                        sb.Append("\t\t\t\treturn \".xyzw\";\n");
                        sb.Append("\t\t}\n\n");
                    }

                    sb.Append($"\t\tpublic static implicit operator {typeName} (float v)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{v}}).{String.Concat(Enumerable.Repeat("x", i))}\" }};\n\n");

                    sb.Append($"\t\tpublic static implicit operator {typeName} (int v)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{v}}.0f).{String.Concat(Enumerable.Repeat("x", i))}\" }};\n\n");

                    sb.Append($"\t\tpublic static {typeName} operator+({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) + ({{y.Code}})\" }};\n");
                    sb.Append("\n");
                    sb.Append($"\t\tpublic static {typeName} operator-({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) - ({{y.Code}})\" }};\n");
                    sb.Append("\n");
                    sb.Append($"\t\tpublic static {typeName} operator*({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) * ({{y.Code}})\" }};\n");
                    sb.Append("\n");
                    sb.Append($"\t\tpublic static {typeName} operator/({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) / ({{y.Code}})\" }};\n");
                    sb.Append("\n");

                    GenerateSwizzle(sb, i);

                    sb.Append("\t}\n");
                    sb.Append("\n");
                }

                for (int i = 1; i <= 3; ++i)
                {
                    var typeName = AnyVectorTypeName(i);
                    sb.Append($"\tpublic struct {typeName}\n");
                    sb.Append("\t{\n");
                    sb.Append($"\t\tpublic string Code;\n\n");

                    sb.Append($"\t\tpublic static {typeName} operator+({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) + ({{y.Code}})\" }};\n");
                    sb.Append("\n");
                    sb.Append($"\t\tpublic static {typeName} operator-({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) - ({{y.Code}})\" }};\n");
                    sb.Append("\n");
                    sb.Append($"\t\tpublic static {typeName} operator*({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) * ({{y.Code}})\" }};\n");
                    sb.Append("\n");
                    sb.Append($"\t\tpublic static {typeName} operator/({typeName} x, {typeName} y)\n");
                    sb.Append($"\t\t\t=> new {typeName}() {{ Code = $\"({{x.Code}}) / ({{y.Code}})\" }};\n");
                    sb.Append("\n");

                    sb.Append("\t}\n");
                    sb.Append("\n");
                }

                sb.Append("}\n");

                sb.Replace("\n", System.Environment.NewLine);
                sb.Replace("\t", "    ");
                stream.WriteLine(sb.ToString());
            }

            AssetDatabase.Refresh();
        }
    }
}
