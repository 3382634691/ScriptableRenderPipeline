
// #pragma
#pragma kernel VolumetricShadowMap               VolumetricShadowMap=VolumetricShadowMap
#pragma kernel VolumetricShadowMapFluidSim       VolumetricShadowMap=VolumetricShadowMapFluidSim FLUID_SIM

#pragma kernel VolumetricShadowMapReproj         VolumetricShadowMap=VolumetricShadowMapReproj         ENABLE_REPROJECTION
#pragma kernel VolumetricShadowMapReprojFluidSim VolumetricShadowMap=VolumetricShadowMapReprojFluidSim ENABLE_REPROJECTION FLUID_SIM

#define TILE_SIZE 4
//#define SOFT_VOXELIZATION

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/VolumeRendering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Core/Utilities/GeometryUtils.cs.hlsl"

#define SHADERPASS SHADERPASS_VOLUME_VOXELIZATION

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightTransmittanceVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricLighting.cs.hlsl"


CBUFFER_START(UnityVShadowMap)
    uint   _NumVisibleDensityVolumes;
    uint   _VBufferLightingHistoryIsValid;
    float4 _VBufferSampleOffset;
CBUFFER_END

#ifndef FLUID_SIM
StructuredBuffer<OrientedBBox>             _VolumeBounds;
StructuredBuffer<DensityVolumeEngineData>  _VolumeData;
#else // FLUID_SIM
StructuredBuffer<OrientedBBox>             _VolumeBounds;
StructuredBuffer<FluidSimVolumeEngineData> _VolumeData;
#endif // FLUID_SIM

static const float Noise4[4][4][4] =
{
     0.0, 48.0, 12.0, 60.0,
    32.0, 16.0, 44.0, 28.0,
     8.0, 56.0,  4.0, 52.0,
    40.0, 24.0, 36.0, 20.0,
    
     3.0, 51.0, 15.0, 63.0,
    35.0, 19.0, 47.0, 13.0,
    11.0, 59.0,  7.0, 55.0,
    43.0, 27.0, 39.0, 23.0,
    
     2.0, 50.0, 14.0, 62.0,
    34.0, 18.0, 46.0, 30.0,
    10.0, 58.0,  6.0, 54.0,
    42.0, 26.0, 38.0, 22.0,
    
     1.0, 49.0, 13.0, 61.0,
    33.0, 17.0, 45.0, 29.0,
     9.0, 57.0,  5.0, 53.0,
    41.0, 25.0, 37.0, 21.0,
};

TEXTURE3D(_VolumeMaskAtlas);
TEXTURE3D(_FluidSimVolumeAtlas);
TEXTURE3D(_VShadowMapBufferHistory);

RWTexture3D<float> _VShadowMapBuffer;


#ifndef FLUID_SIM
#else // FLUID_SIM
float4 SampleFluidSimVolume(FluidSimVolumeEngineData volumeData, float3 voxelCenterNDC)
{
    // todo : sync atlas resolution
    float3 voxelCenterUVW = frac(voxelCenterNDC * (volumeData.volumeRes / 512.0));

    return SAMPLE_TEXTURE3D_LOD(_FluidSimVolumeAtlas, s_linear_repeat_sampler, voxelCenterUVW, 0);
}
#endif // FLUID_SIM


[numthreads(TILE_SIZE, TILE_SIZE, TILE_SIZE)]
void VolumetricShadowMap(uint3 id : SV_DispatchThreadID)
{
    uint  vshadowMapHalfRes = _VShadowMapRes / 2;
    float vshadowMapRes = (float)_VShadowMapRes;
    
    #ifdef ENABLE_REPROJECTION
    uint frameIndex = (uint)_VBufferSampleOffset.w;    
    uint3 ni = (id.xyz + frameIndex) % 4;
    float3 coordOffset = Noise4[ni.x][ni.y][ni.z] / 64.0;
    #else 
    uint3 ni = id.xyz % 4;
    float3 coordOffset = Noise4[ni.x][ni.y][ni.z] / 64.0;
    #endif
    
    float3 voxelCoordNonJittered = id.xyz + 0.5;
    float3 voxelCoord = voxelCoordNonJittered + coordOffset;
    float3 voxelCenterWS = ((voxelCoord - vshadowMapHalfRes) / vshadowMapRes) * _VShadowMapMag;
    
    // in LightLoop, these are dependent on Tile Lightlist. but here is not using it
    uint volumeCount = _NumVisibleDensityVolumes;
    uint volumeStart = 0;
    
    float3 voxelScattering = 0.0;
    float  voxelExtinction = 0.0;
    
    for (uint volumeOffset = 0; volumeOffset < volumeCount; volumeOffset++)
    {
        // in LightLoop, these are dependent on Tile Lightlist. but here is not using it
        uint volumeIndex = volumeOffset;
        const OrientedBBox obb = _VolumeBounds[volumeIndex];

        const float3x3 obbFrame   = float3x3(obb.right, obb.up, cross(obb.up, obb.right));
        const float3   obbExtents = float3(obb.extentX, obb.extentY, obb.extentZ);

        // Express the voxel center in the local coordinate system of the box.
        const float3 voxelCenterBS = mul(voxelCenterWS - obb.center, transpose(obbFrame));
        const float3 voxelCenterCS = (voxelCenterBS * rcp(obbExtents));
        
        // not use SOFT_VOXELIZATION
    #ifdef SOFT_VOXELIZATION
    #else // SOFT_VOXELIZATION
        bool overlap = Max3(abs(voxelCenterCS.x), abs(voxelCenterCS.y), abs(voxelCenterCS.z)) <= 1;

        float overlapFraction = overlap ? 1 : 0;
    #endif //SOFT_VOXELIZATION
    
        if (overlapFraction > 0)
        {
            float3 voxelCenterNDC = saturate(voxelCenterCS * 0.5 + 0.5);
            
            bool useVolumetricShadowing =
                _VolumeData[volumeIndex].textureIndex != -1 &&
                _VolumeData[volumeIndex].volumetricShadowing == 1;

            if (useVolumetricShadowing)
            {
            #ifndef FLUID_SIM
            #else // FLUID_SIM
                float4 density = SampleFluidSimVolume(_VolumeData[volumeIndex], voxelCenterNDC);
            
                voxelScattering = density.xyz;
                voxelExtinction = dot(voxelScattering, 0.3333) + density.w;
            #endif // FLUID_SIM
            }
        }
    }
    
    #ifdef ENABLE_REPROJECTION
    bool reprojSuccess = _VBufferLightingHistoryIsValid != 0;
    if (reprojSuccess)
    {
        float3 voxelCenterNonJitteredWS = ((voxelCoordNonJittered - vshadowMapHalfRes) / vshadowMapRes) * _VShadowMapMag;
    
        float3 historyUVW = (voxelCenterNonJitteredWS + _PrevCamPosRWS) / _VShadowMapMag + 0.5;
        float voxelExtinctionHistory = SAMPLE_TEXTURE3D_LOD(_VShadowMapBufferHistory, s_linear_repeat_sampler, historyUVW, 0).x;
        voxelExtinction = lerp(voxelExtinction, voxelExtinctionHistory, 0.99);
    }
    #endif

    _VShadowMapBuffer[id.xyz] = voxelExtinction;
}
