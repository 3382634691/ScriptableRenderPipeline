
// #pragma
#pragma kernel VolumetricShadowMap         VolumetricShadowMap=VolumetricShadowMap
#pragma kernel VolumetricShadowMapFluidSim VolumetricShadowMap=VolumetricShadowMapFluidSim FLUID_SIM

#define TILE_SIZE 4

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/VolumeRendering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Core/Utilities/GeometryUtils.cs.hlsl"

#define SHADERPASS SHADERPASS_VOLUME_VOXELIZATION

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricLighting.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VShadowMapVariables.hlsl"


CBUFFER_START(UnityVShadowMap)
    uint _NumVisibleDensityVolumes;
CBUFFER_END

#ifndef FLUID_SIM
StructuredBuffer<OrientedBBox>             _VolumeBounds;
StructuredBuffer<DensityVolumeEngineData>  _VolumeData;
#else // FLUID_SIM
StructuredBuffer<OrientedBBox>             _VolumeBounds;
StructuredBuffer<FluidSimVolumeEngineData> _VolumeData;
#endif // FLUID_SIM

TEXTURE3D(_VolumeMaskAtlas);
TEXTURE3D(_FluidSimVolumeAtlas);

RWTexture3D<float> _VShadowMapBuffer;


#ifndef FLUID_SIM
#else // FLUID_SIM
float4 SampleFluidSimVolume(FluidSimVolumeEngineData volumeData, float3 voxelCenterNDC)
{
    // todo : sync atlas resolution
    float3 voxelCenterUVW = frac(voxelCenterNDC * (volumeData.volumeRes / 512.0));
    voxelCenterUVW = voxelCenterNDC * 0.07;

    return SAMPLE_TEXTURE3D_LOD(_FluidSimVolumeAtlas, s_linear_repeat_sampler, voxelCenterUVW, 0);
}
#endif // FLUID_SIM


[numthreads(TILE_SIZE, TILE_SIZE, TILE_SIZE)]
void VolumetricShadowMap(uint3 id : SV_DispatchThreadID)
{
    uint  vshadowMapHalfRes = _VShadowMapRes / 2;
    float vshadowMapRes = (float)_VShadowMapRes;
    
    uint3  voxelCoord = id.xyz;
    float3 voxelCenterWS = (((float3)voxelCoord - vshadowMapHalfRes) / vshadowMapRes) * _VShadowMapMag;
    
    // in LightLoop, these are dependent on Tile Lightlist. but here is not using it
    uint volumeCount = _NumVisibleDensityVolumes;
    uint volumeStart = 0;
    
    float3 voxelScattering = 0.0;
    float  voxelExtinction = 0.0;
    
    for (uint volumeOffset = 0; volumeOffset < volumeCount; volumeOffset++)
    {
        // in LightLoop, these are dependent on Tile Lightlist. but here is not using it
        uint volumeIndex = volumeOffset;
        const OrientedBBox obb = _VolumeBounds[volumeIndex];

        const float3x3 obbFrame   = float3x3(obb.right, obb.up, cross(obb.up, obb.right));
        const float3   obbExtents = float3(obb.extentX, obb.extentY, obb.extentZ);

        // Express the voxel center in the local coordinate system of the box.
        const float3 voxelCenterBS = mul(voxelCenterWS - obb.center, transpose(obbFrame));
        const float3 voxelCenterCS = (voxelCenterBS * rcp(obbExtents));
        
        // not use SOFT_VOXELIZATION
    #if SOFT_VOXELIZATION
    #else // SOFT_VOXELIZATION
        bool overlap = Max3(abs(voxelCenterCS.x), abs(voxelCenterCS.y), abs(voxelCenterCS.z)) <= 1;

        float overlapFraction = overlap ? 1 : 0;
    #endif //SOFT_VOXELIZATION
    
        if (overlapFraction > 0)
        {
            float3 voxelCenterNDC = saturate(voxelCenterCS * 0.5 + 0.5);

            if (_VolumeData[volumeIndex].textureIndex != -1)
            {
            #ifndef FLUID_SIM
            #else // FLUID_SIM
                float4 density = SampleFluidSimVolume(_VolumeData[volumeIndex], voxelCenterNDC);
            
                voxelScattering = density.xyz;
                voxelExtinction = dot(voxelScattering, 0.3333) + density.w;
            #endif // FLUID_SIM
            }
        }
    }

    _VShadowMapBuffer[voxelCoord] = voxelExtinction * 10.0;
}
