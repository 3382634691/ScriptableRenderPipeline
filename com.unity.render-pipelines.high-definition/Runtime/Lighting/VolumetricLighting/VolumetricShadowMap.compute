
// #pragma
#pragma kernel VolumetricShadowMap               VolumetricShadowMap=VolumetricShadowMap
#pragma kernel VolumetricShadowMapFluidSim       VolumetricShadowMap=VolumetricShadowMapFluidSim FLUID_SIM

#pragma kernel VolumetricShadowMapReproj         VolumetricShadowMap=VolumetricShadowMapReproj         ENABLE_REPROJECTION
#pragma kernel VolumetricShadowMapReprojFluidSim VolumetricShadowMap=VolumetricShadowMapReprojFluidSim ENABLE_REPROJECTION FLUID_SIM

#define TILE_SIZE 4
//#define SOFT_VOXELIZATION

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/VolumeRendering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Core/Utilities/GeometryUtils.cs.hlsl"

#define SHADERPASS SHADERPASS_VOLUME_VOXELIZATION

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightTransmittanceVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricLighting.cs.hlsl"


CBUFFER_START(UnityVShadowMap)
    uint   _NumVisibleDensityVolumes;
    uint   _VBufferLightingHistoryIsValid;
    float4 _VBufferSampleOffset;
    float  _Halton2[8];
    float  _Halton3[8];
    float  _Halton5[8];
CBUFFER_END

#ifndef FLUID_SIM
StructuredBuffer<OrientedBBox>             _VolumeBounds;
StructuredBuffer<DensityVolumeEngineData>  _VolumeData;
#else // FLUID_SIM
StructuredBuffer<OrientedBBox>             _VolumeBounds;
StructuredBuffer<FluidSimVolumeEngineData> _VolumeData;
#endif // FLUID_SIM

static const float Noise4[4][4][4] =
{
     0.0 / 64.0, 48.0 / 64.0, 12.0 / 64.0, 60.0 / 64.0,
    32.0 / 64.0, 16.0 / 64.0, 44.0 / 64.0, 28.0 / 64.0,
     8.0 / 64.0, 56.0 / 64.0,  4.0 / 64.0, 52.0 / 64.0,
    40.0 / 64.0, 24.0 / 64.0, 36.0 / 64.0, 20.0 / 64.0,
    
     3.0 / 64.0, 51.0 / 64.0, 15.0 / 64.0, 63.0 / 64.0,
    35.0 / 64.0, 19.0 / 64.0, 47.0 / 64.0, 13.0 / 64.0,
    11.0 / 64.0, 59.0 / 64.0,  7.0 / 64.0, 55.0 / 64.0,
    43.0 / 64.0, 27.0 / 64.0, 39.0 / 64.0, 23.0 / 64.0,
    
     2.0 / 64.0, 50.0 / 64.0, 14.0 / 64.0, 62.0 / 64.0,
    34.0 / 64.0, 18.0 / 64.0, 46.0 / 64.0, 30.0 / 64.0,
    10.0 / 64.0, 58.0 / 64.0,  6.0 / 64.0, 54.0 / 64.0,
    42.0 / 64.0, 26.0 / 64.0, 38.0 / 64.0, 22.0 / 64.0,
    
     1.0 / 64.0, 49.0 / 64.0, 13.0 / 64.0, 61.0 / 64.0,
    33.0 / 64.0, 17.0 / 64.0, 45.0 / 64.0, 29.0 / 64.0,
     9.0 / 64.0, 57.0 / 64.0,  5.0 / 64.0, 53.0 / 64.0,
    41.0 / 64.0, 25.0 / 64.0, 37.0 / 64.0, 21.0 / 64.0,
};
static const float Noise2[2][2][2] =
{
    1.0 / 2.0,
    1.0 / 4.0,
    
    3.0 / 4.0,
    1.0 / 8.0,
    
    5.0 / 8.0,
    3.0 / 8.0,
    
    7.0 / 8.0,
    1.0 / 16.0,
};

TEXTURE3D(_VolumeMaskAtlas);
TEXTURE3D(_FluidSimVolumeAtlas);
TEXTURE3D(_VShadowMapBufferHistory);

RWTexture3D<float4> _VShadowMapBuffer;


#ifndef FLUID_SIM
#else // FLUID_SIM
float4 SampleFluidSimVolume(FluidSimVolumeEngineData volumeData, float3 voxelCenterNDC)
{
    // todo : sync atlas resolution
    float3 voxelCenterUVW = frac(voxelCenterNDC * (volumeData.volumeRes / 512.0));

    return SAMPLE_TEXTURE3D_LOD(_FluidSimVolumeAtlas, s_linear_repeat_sampler, voxelCenterUVW, 0);
}
#endif // FLUID_SIM

[numthreads(TILE_SIZE, TILE_SIZE, TILE_SIZE)]
void VolumetricShadowMap(uint3 id : SV_DispatchThreadID)
{
    uint  vshadowMapHalfRes = _VShadowMapRes / 2;
    float vshadowMapRes = (float)_VShadowMapRes;
    

#if 0
    #ifdef ENABLE_REPROJECTION
    uint frameIndex = (uint)_VBufferSampleOffset.w;    
    uint3 ni = (id.xyz + frameIndex) % 4;
    float3 coordOffset = Noise4[ni.x][ni.y][ni.z];
    #else
    uint3 ni = id.xyz % 4;
    float3 coordOffset = Noise4[ni.x][ni.y][ni.z];
    #endif
#elif 0
    #ifdef ENABLE_REPROJECTION
    uint frameIndex = (uint)_VBufferSampleOffset.w;
    uint3 ni = (id.xyz + frameIndex) % 2;
    float3 coordOffset = Noise2[ni.x][ni.y][ni.z];
    #else
    uint3 ni = id.xyz % 2;
    float3 coordOffset = Noise2[ni.x][ni.y][ni.z];
    #endif
#elif 1
    #ifdef ENABLE_REPROJECTION
    uint frameIndex = (uint)_VBufferSampleOffset.w; 
    uint3 ni = (id.xyz + frameIndex) % 8;
    float3 coordOffset = float3(_Halton2[ni.x], _Halton3[ni.y], _Halton5[ni.z]);
    #else
    uint3 ni = id.xyz % 8;
    float3 coordOffset = float3(_Halton2[ni.x], _Halton3[ni.y], _Halton5[ni.z]);
    #endif
#else
    float3 coordOffset = 0.0;
#endif
    
    float3 voxelCoordNonJittered = id.xyz + 0.5;
    float3 voxelCoord = voxelCoordNonJittered + coordOffset;
    float3 voxelCenterWS = ((voxelCoord - vshadowMapHalfRes) / vshadowMapRes) * _VShadowMapMag;
    
    // in LightLoop, these are dependent on Tile Lightlist. but here is not using it
    uint volumeCount = _NumVisibleDensityVolumes;
    uint volumeStart = 0;
    
    float4 voxelDensity = 0.0;
    
    for (uint volumeOffset = 0; volumeOffset < volumeCount; volumeOffset++)
    {
        // in LightLoop, these are dependent on Tile Lightlist. but here is not using it
        uint volumeIndex = volumeOffset;
        const OrientedBBox obb = _VolumeBounds[volumeIndex];

        const float3x3 obbFrame   = float3x3(obb.right, obb.up, cross(obb.up, obb.right));
        const float3   obbExtents = float3(obb.extentX, obb.extentY, obb.extentZ);

        // Express the voxel center in the local coordinate system of the box.
        const float3 voxelCenterBS = mul(voxelCenterWS - obb.center, transpose(obbFrame));
        const float3 voxelCenterCS = (voxelCenterBS * rcp(obbExtents));
        
        // not use SOFT_VOXELIZATION
    #ifdef SOFT_VOXELIZATION
    #else // SOFT_VOXELIZATION
        bool overlap = Max3(abs(voxelCenterCS.x), abs(voxelCenterCS.y), abs(voxelCenterCS.z)) <= 1;

        float overlapFraction = overlap ? 1 : 0;
    #endif //SOFT_VOXELIZATION
    
        if (overlapFraction > 0)
        {
            float3 voxelCenterNDC = saturate(voxelCenterCS * 0.5 + 0.5);
            
            bool useVolumetricShadowing =
                _VolumeData[volumeIndex].textureIndex != -1 &&
                _VolumeData[volumeIndex].volumetricShadowing == 1;

            if (useVolumetricShadowing)
            {
            #ifndef FLUID_SIM
            #else // FLUID_SIM
                float4 density = SampleFluidSimVolume(_VolumeData[volumeIndex], voxelCenterNDC);
                voxelDensity += density;
            #endif // FLUID_SIM
            }
        }
    }
    
    #ifdef ENABLE_REPROJECTION
    bool reprojSuccess = _VBufferLightingHistoryIsValid != 0;
    if (reprojSuccess)
    {
        float3 voxelCenterNonJitteredWS = ((voxelCoordNonJittered - vshadowMapHalfRes) / vshadowMapRes) * _VShadowMapMag;
    
        float3 historyUVW = (voxelCenterNonJitteredWS + _PrevCamPosRWS) / _VShadowMapMag + 0.5;
        float4 voxelDensityHistory = SAMPLE_TEXTURE3D_LOD(_VShadowMapBufferHistory, s_linear_repeat_sampler, historyUVW, 0);
        voxelDensity = lerp(voxelDensity, voxelDensityHistory, 0.75);
    }
    #endif

    _VShadowMapBuffer[id.xyz] = voxelDensity;
}
