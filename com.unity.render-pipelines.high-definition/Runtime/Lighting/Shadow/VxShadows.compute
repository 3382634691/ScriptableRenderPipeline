//seongdae;vxsm
#pragma kernel DeferredVxShadowNearest              DEFERRED_VX_SHADOW_GENERIC=DeferredVxShadowNearest                VX_SHADOWS NEAREST_SAMPLE
#pragma kernel DeferredVxShadowBilinear             DEFERRED_VX_SHADOW_GENERIC=DeferredVxShadowBilinear               VX_SHADOWS BILINEAR_SAMPLE
#pragma kernel DeferredVxShadowTrilinear            DEFERRED_VX_SHADOW_GENERIC=DeferredVxShadowTrilinear              VX_SHADOWS TRILINEAR_SAMPLE
#pragma kernel DeferredVxShadowNearestMSAA          DEFERRED_VX_SHADOW_GENERIC=DeferredVxShadowNearestMSAA            VX_SHADOWS NEAREST_SAMPLE   ENABLE_MSAA
#pragma kernel DeferredVxShadowBilinearMSAA         DEFERRED_VX_SHADOW_GENERIC=DeferredVxShadowBilinearMSAA           VX_SHADOWS BILINEAR_SAMPLE  ENABLE_MSAA
#pragma kernel DeferredVxShadowTrilinearMSAA        DEFERRED_VX_SHADOW_GENERIC=DeferredVxShadowTrilinearMSAA          VX_SHADOWS TRILINEAR_SAMPLE ENABLE_MSAA

#ifdef SHADER_API_PSSL
#   pragma argument( scheduler=minpressure ) // instruct the shader compiler to prefer minimizing vgpr usage
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl"
#include "Packages/com.unity.voxelized-shadows/ShaderLibrary/Common.hlsl"

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// #pragma enable_d3d11_debug_symbols

#ifdef ENABLE_MSAA
    TEXTURE2D_X(_CameraDepthValues);
#endif

RW_TEXTURE2D_X(float, _VxShadowTextureUAV);

#define DEFERRED_SHADOW_TILE_SIZE 16


uint TraverseVxShadowMapPosQEarly(uint begin, uint typeOffset, uint3 posQ, uint loopScale, out uint2 result)
{
    uint vxsmOffset = begin + typeOffset;
    uint dagScale = _VxShadowMapsBuffer[begin + 2];

    uint scaleShift = dagScale - 2;
    uint nodeIndex = 0;
    uint shadowbit = 0;

    bool intersected = true;

    for (; scaleShift > loopScale && intersected; --scaleShift)
    {
        // get childmask
        uint vxsmAccess = vxsmOffset + nodeIndex;
        uint childmask = _VxShadowMapsBuffer[vxsmAccess] >> 16;

        // calculate where to go to child
        uint3 childDet = ((posQ >> scaleShift) & 0x00000002) << uint3(0, 1, 2);
        uint cellShift = childDet.x + childDet.y + childDet.z;
        uint cellbit   = 0x00000003 << cellShift;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        shadowbit = (childmask & cellbit) >> cellShift;
        intersected = shadowbit == 0x00000003;

        // find next child node
        uint mask = ~(0xFFFFFFFF << cellShift);
        uint childrenbit = childmask & ((childmask & 0x0000AAAA) >> 1);
        uint childIndex = countBits(childrenbit & mask) + 1;

        // go down to the next node
        vxsmAccess += childIndex;
        nodeIndex = _VxShadowMapsBuffer[vxsmAccess];
    }

    result = uint2(nodeIndex, shadowbit);

    return scaleShift;
}

uint TraverseVxShadowMapPosQ2x2Early(uint begin, uint typeOffset, uint2 delta, uint3 posQ, uint loopScale, out uint4 results[2])
{
    uint vxsmOffset = begin + typeOffset;
    uint dagScale = _VxShadowMapsBuffer[begin + 2];

    uint4 posQ_01 = posQ.xyxy + uint4(0, 0, delta.x, 0);
    uint4 posQ_23 = posQ.xyxy + uint4(0, delta.yxy);

    uint scaleShift = dagScale - 2;
    uint4 nodeIndex4 = 0;
    uint4 shadowbit4 = 0;

    bool4 intersected4 = true;

    for (; scaleShift > loopScale && any(intersected4); --scaleShift)
    {
        // calculate where to go to child
        uint4 childDet_01 = ((posQ_01 >> scaleShift) & 0x00000002) << uint4(0, 1, 0, 1);
        uint4 childDet_23 = ((posQ_23 >> scaleShift) & 0x00000002) << uint4(0, 1, 0, 1);
        uint  childDet_z  = ((posQ.z  >> scaleShift) & 0x00000002) << 2;
        uint4 cellShift4 = SumDet(childDet_01, childDet_23) + childDet_z;
        uint4 cellbit4 = 0x00000003 << cellShift4;
        uint4 mask4 = ~(0xFFFFFFFF << cellShift4);

        // get childmask
        uint4 vxsmAccess4 = vxsmOffset + nodeIndex4;
        uint4 childmask4 = AccessVxShadowMaps(vxsmAccess4) >> 16;

        // find next child node
        uint4 childrenbit4 = childmask4 & ((childmask4 & 0x0000AAAA) >> 1);
        uint4 childIndex4 = countBits(childrenbit4 & mask4) + 1;

        // if it has lit and shadowed, it is not decided yet(need to traverse more)
        shadowbit4 = intersected4 ? (childmask4 & cellbit4) >> cellShift4 : shadowbit4;
        intersected4 = shadowbit4 == 0x00000003;

        // go down to the next node
        vxsmAccess4 += childIndex4;
        nodeIndex4 = intersected4 ? AccessVxShadowMaps(vxsmAccess4) : nodeIndex4;
    }

    results[0] = nodeIndex4;
    results[1] = shadowbit4;

    return scaleShift;
}

float TraverseNearestSampleVxShadowMapEarly(uint begin, uint typeOffset, uint3 posQ, uint2 innerResult)
{
    uint vxsmOffset = begin + typeOffset;
    uint nodeIndex = innerResult.x;

    uint3 leaf = posQ % uint3(8, 8, 8);
    uint leafIndex = _VxShadowMapsBuffer[vxsmOffset + nodeIndex + leaf.z];
    if (leaf.y >= 4) leafIndex++;

    uint bitmask = _VxShadowMapsBuffer[vxsmOffset + leafIndex];

    uint maskShift = leaf.x + 8 * (leaf.y % 4);
    uint mask = 0x00000001 << maskShift;

    float attenuation = (bitmask & mask) == 0 ? 1.0 : 0.0;

    return attenuation;
}

float TraverseBilinearSampleVxShadowMapEarly(uint begin, uint typeOffset, uint3 posQ, uint4 innerResults[2], float2 lerpWeight)
{
    uint vxsmOffset = begin + typeOffset;
    uint4 nodeIndex4 = vxsmOffset + innerResults[0];

    uint4 posQ_x = posQ.xxxx + uint4(0, 1, 0, 1);
    uint4 posQ_y = posQ.yyyy + uint4(0, 0, 1, 1);

    uint4 leaf4_x = posQ_x % 8;
    uint4 leaf4_y = posQ_y % 8;
    uint  leaf4_z = posQ.z % 8;

    uint4 leafOffset = leaf4_y < 4 ? 0 : 1;
    uint4 leafIndex = vxsmOffset + uint4(
        _VxShadowMapsBuffer[nodeIndex4.x + leaf4_z],
        _VxShadowMapsBuffer[nodeIndex4.y + leaf4_z],
        _VxShadowMapsBuffer[nodeIndex4.z + leaf4_z],
        _VxShadowMapsBuffer[nodeIndex4.w + leaf4_z]) + leafOffset;

    uint4 bitmask4 = (innerResults[1] & VX_SHADOWS_LIT) ? 0x00000000 : 0xFFFFFFFF;

    if (innerResults[1].x == VX_SHADOWS_INTERSECTED) bitmask4.x = _VxShadowMapsBuffer[leafIndex.x];
    if (innerResults[1].y == VX_SHADOWS_INTERSECTED) bitmask4.y = _VxShadowMapsBuffer[leafIndex.y];
    if (innerResults[1].z == VX_SHADOWS_INTERSECTED) bitmask4.z = _VxShadowMapsBuffer[leafIndex.z];
    if (innerResults[1].w == VX_SHADOWS_INTERSECTED) bitmask4.w = _VxShadowMapsBuffer[leafIndex.w];

    uint4 maskShift4 = mad(leaf4_y % 4, 8, leaf4_x);
    uint4 mask4 = uint4(1, 1, 1, 1) << maskShift4;

    float4 attenuation4 = (bitmask4 & mask4) == 0 ? 1.0 : 0.0;
    attenuation4.xy = lerp(attenuation4.xz, attenuation4.yw, lerpWeight.x);
    attenuation4.x  = lerp(attenuation4.x,  attenuation4.y,  lerpWeight.y);

    return attenuation4.x;
}


[numthreads(DEFERRED_SHADOW_TILE_SIZE, DEFERRED_SHADOW_TILE_SIZE, 1)]
void DEFERRED_VX_SHADOW_GENERIC(uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID, uint3 dispatchThreadId : SV_DispatchThreadID)
{
    UNITY_STEREO_ASSIGN_COMPUTE_EYE_INDEX(dispatchThreadId.z);

    uint2 pixelCoord = groupId * DEFERRED_SHADOW_TILE_SIZE + groupThreadId;
    uint2 tileCoord = groupId;

#ifdef ENABLE_MSAA
    float depth = LOAD_TEXTURE2D_X(_CameraDepthValues, pixelCoord.xy).z;
#else
    float depth = LoadCameraDepth(pixelCoord.xy);
#endif

    if (depth == UNITY_RAW_FAR_CLIP_VALUE)
    {
        _VxShadowTextureUAV[COORD_TEXTURE2D_X(pixelCoord)] = 1;
        return;
    }

    PositionInputs posInput = GetPositionInput(pixelCoord.xy, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V, tileCoord);
    float3 positionWS = posInput.positionWS + _WorldSpaceCameraPos;

    NormalData normalData;
    DecodeFromNormalBuffer(posInput.positionSS, normalData);

    DirectionalLightData light = _DirectionalLightDatas[_DirectionalShadowIndex];

    uint begin = MaskBitsetVxShadowMapBegin(light.vxShadowsBitset);

    float volumeScale = asfloat(_VxShadowMapsBuffer[begin + 1]);
    uint dagScale = _VxShadowMapsBuffer[begin + 2];
    float4x4 worldToShadowMatrix =
    {
        asfloat(_VxShadowMapsBuffer[begin +  3]),
        asfloat(_VxShadowMapsBuffer[begin +  4]),
        asfloat(_VxShadowMapsBuffer[begin +  5]),
        asfloat(_VxShadowMapsBuffer[begin +  6]),

        asfloat(_VxShadowMapsBuffer[begin +  7]),
        asfloat(_VxShadowMapsBuffer[begin +  8]),
        asfloat(_VxShadowMapsBuffer[begin +  9]),
        asfloat(_VxShadowMapsBuffer[begin + 10]),

        asfloat(_VxShadowMapsBuffer[begin + 11]),
        asfloat(_VxShadowMapsBuffer[begin + 12]),
        asfloat(_VxShadowMapsBuffer[begin + 13]),
        asfloat(_VxShadowMapsBuffer[begin + 14]),

        0.0, 0.0, 0.0, 1.0,
    };

    uint voxelResolution = 1 << dagScale;
    float voxelScale = volumeScale / (float)voxelResolution;
    float normalBias = 2.0 * voxelScale;

    positionWS += (normalData.normalWS * normalBias);

    float3 posNDC = mul(worldToShadowMatrix, float4(positionWS, 1.0)).xyz;
    float3 posP = posNDC * (float)voxelResolution;
    float3 posF = floor(posP);
    float3 lerpWeight = posP - posF;

    uint3 posQ = (uint3)posP;

    if (any(posQ >= (voxelResolution.xxx - 1)))
    {
        _VxShadowTextureUAV[COORD_TEXTURE2D_X(pixelCoord)] = 1;
        return;
    }

    float linearDepth = LinearEyeDepth(posInput.positionWS, UNITY_MATRIX_V);
    float cmp = log2((1.0 * linearDepth * _ScreenSize.z) / voxelScale);

    uint loopScale = max(1, (int)cmp - 2);
    bool earlyTerm = 1 < loopScale;

    float shadowing = 1.0;

#if 1//NEAREST_SAMPLE
    uint2 result;
    TraverseVxShadowMapPosQEarly(begin, OFFSET_DIR, posQ, loopScale, result);

    if (result.y != VX_SHADOWS_INTERSECTED || earlyTerm)
    {
        float weight = earlyTerm ? pow((float)loopScale / (float)dagScale, 0.5) : 0.0;

        shadowing = (result.y & 0x00000002) ? weight : 1.0;
        _VxShadowTextureUAV[COORD_TEXTURE2D_X(pixelCoord)] = shadowing;
        return;
    }

    shadowing = TraverseNearestSampleVxShadowMapEarly(begin, OFFSET_DIR, posQ, result);
#elif BILINEAR_SAMPLE
    uint4 results[2];
    uint2 delta = earlyTerm ? 0 : 1;

    TraverseVxShadowMapPosQ2x2Early(begin, OFFSET_DIR, delta, posQ, loopScale, results);

    if (all(results[1] != VX_SHADOWS_INTERSECTED) || earlyTerm)
    {
        float weight = earlyTerm ? pow((float)loopScale / (float)dagScale, 1.0) : 0.0;

        float4 shadowing4 = results[1] & 0x000000001 ? 1.0 : weight;
        shadowing4.xy = lerp(shadowing4.xz, shadowing4.yw, lerpWeight.x);

        shadowing = lerp(shadowing4.x, shadowing4.y, lerpWeight.y);
        _VxShadowTextureUAV[COORD_TEXTURE2D_X(pixelCoord)] = shadowing;
        return;
    }

    shadowing = TraverseBilinearSampleVxShadowMapEarly(begin, OFFSET_DIR, posQ, results, lerpWeight.xy);
#elif TRILINEAR_SAMPLE
    uint4 results[4];
    TraverseVxShadowMapPosQ2x2x2(begin, OFFSET_DIR, posQ, results);

    if (all(results[2] != VX_SHADOWS_INTERSECTED) && all(results[3] != VX_SHADOWS_INTERSECTED))
    {
        float4 shadowing4_0 = results[2] & 0x000000001 ? 1.0 : 0.0;
        float4 shadowing4_1 = results[3] & 0x000000001 ? 1.0 : 0.0;

        shadowing4_0    = lerp(shadowing4_0,    shadowing4_1,    lerpWeight.x);
        shadowing4_0.xy = lerp(shadowing4_0.xz, shadowing4_0.yw, lerpWeight.y);

        shadowing = lerp(shadowing4_0.x, shadowing4_0.y, lerpWeight.z);
        _VxShadowTextureUAV[COORD_TEXTURE2D_X(pixelCoord)] = shadowing;
        return;
    }

    shadowing = TravereTrilinearSampleVxShadowMap(begin, OFFSET_DIR, posQ, results, lerpWeight);
#endif

    _VxShadowTextureUAV[COORD_TEXTURE2D_X(pixelCoord)] = shadowing;
}
//seongdae;vxsm
