Pass
{
    Name "ShadowCaster"
    Tags{"LightMode" = "ShadowCaster"}

    ZWrite On ZTest LEqual

    // Material options generated by graph
${Culling}
    HLSLPROGRAM
    // Required to compile gles 2.0 with standard srp library
    #pragma prefer_hlslcc gles
    #pragma exclude_renderers d3d11_9x
    #pragma target 2.0

    //--------------------------------------
    // GPU Instancing
    #pragma multi_compile_instancing

    #pragma vertex ShadowPassVertex
    #pragma fragment ShadowPassFragment

    // Defines generated by graph
${Defines}
    #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
    #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
    #include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
    #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

${Graph}
    struct VertexOutput
    {
        float2 uv           : TEXCOORD0;
        float4 clipPos      : SV_POSITION;
        // Interpolators defined by graph
${VertexOutputStruct}
        UNITY_VERTEX_INPUT_INSTANCE_ID
    };

    float3 _LightDirection;

    VertexOutput ShadowPassVertex(GraphVertexInput v)
    {
        VertexOutput o;
        UNITY_SETUP_INSTANCE_ID(v);
        UNITY_TRANSFER_INSTANCE_ID(v, o);

        // Vertex transformations performed by graph
${VertexShader}
        VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        // Vertex description inputs defined by graph
${VertexShaderDescriptionInputs}
        VertexDescription vd = PopulateVertexData(vdi);
        v.vertex.xyz = vd.Position;

        // Vertex shader outputs defined by graph
${VertexShaderOutputs}
        
        float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
        float3 normalWS = TransformObjectToWorldNormal(v.normal);

        float4 clipPos = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection));

    #if UNITY_REVERSED_Z
        clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
    #else
        clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
    #endif
        o.clipPos = clipPos;

        return o;
    }

    half4 ShadowPassFragment(VertexOutput IN ${FaceSign}) : SV_TARGET
    {
        UNITY_SETUP_INSTANCE_ID(IN);

        // Pixel transformations performed by graph
${PixelShader}
        SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        // Surface description inputs defined by graph
${PixelShaderSurfaceInputs}
        SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        float3 Albedo = float3(0.5, 0.5, 0.5);
        float3 Emission = 0;
        float Alpha = 1;
        float AlphaClipThreshold = 0;

        // Surface description remap performed by graph
${PixelShaderSurfaceRemap}
 #if _AlphaClip
        clip(Alpha - AlphaClipThreshold);
#endif
        return 0;
    }

    ENDHLSL
}